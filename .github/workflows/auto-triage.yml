name: Auto Issue Triage

on:
  issues:
    types: [opened]

permissions:
  issues: write
  contents: read

jobs:
  triage:
    runs-on: ubuntu-latest
    steps:
      - name: Triage Issue with LLM
        uses: actions/github-script@v7
        env:
          # Pass potentially untrusted inputs as environment variables (security best practice)
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_LABELS: ${{ toJson(github.event.issue.labels) }}
          # LLM configuration from secrets
          LLM_API_BASE: ${{ secrets.LLM_API_BASE }}
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
          LLM_MODEL: ${{ secrets.LLM_MODEL }}
        with:
          script: |
            // Read from environment variables (safe from injection)
            const issueTitle = process.env.ISSUE_TITLE || '';
            const issueBody = process.env.ISSUE_BODY || 'No description provided';
            const issueNumber = parseInt(process.env.ISSUE_NUMBER, 10);
            const existingLabels = JSON.parse(process.env.ISSUE_LABELS || '[]');

            // Skip if issue already has labels
            if (existingLabels && existingLabels.length > 0) {
              console.log('Issue already has labels, skipping triage');
              return;
            }

            const apiBase = process.env.LLM_API_BASE || 'https://api.deepseek.com/v1';
            const model = process.env.LLM_MODEL || 'deepseek-chat';
            const apiKey = process.env.LLM_API_KEY;

            if (!apiKey) {
              console.log('LLM_API_KEY not configured, skipping auto-triage');
              return;
            }

            try {
              const response = await fetch(`${apiBase}/chat/completions`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${apiKey}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  model: model,
                  messages: [{
                    role: 'system',
                    content: `You are an issue triage bot for Driftlock, a compression-based anomaly detection platform.
                    Analyze GitHub issues and respond with ONLY valid JSON, no markdown or explanation.

                    Priority levels:
                    - P0: Critical - System down, security vulnerability, data loss
                    - P1: High - Major feature broken, significant user impact
                    - P2: Medium - Feature request, moderate bugs, improvements
                    - P3: Low - Minor issues, cosmetic, nice-to-have

                    Types:
                    - bug: Something is broken or not working as expected
                    - feature: New functionality or enhancement request
                    - docs: Documentation updates or additions
                    - chore: Maintenance, refactoring, dependencies

                    Teams:
                    - Core: CBAD algorithms, Rust code, compression, Go backend
                    - Frontend: Vue.js, landing page, dashboard, UI/UX
                    - Infra: DevOps, deployment, CI/CD, monitoring`
                  }, {
                    role: 'user',
                    content: `Analyze this GitHub issue and respond with JSON only:
                    {"priority": "P0|P1|P2|P3", "type": "bug|feature|docs|chore", "team": "Core|Frontend|Infra"}

                    Title: ${issueTitle}
                    Body: ${issueBody.substring(0, 2000)}`
                  }],
                  temperature: 0.1,
                  max_tokens: 100
                })
              });

              if (!response.ok) {
                console.error('LLM API error:', response.status, await response.text());
                return;
              }

              const result = await response.json();
              const content = result.choices[0].message.content.trim();

              // Parse JSON, handling potential markdown code blocks
              let jsonStr = content;
              if (content.includes('```')) {
                jsonStr = content.replace(/```json?\n?/g, '').replace(/```/g, '').trim();
              }

              const labels = JSON.parse(jsonStr);

              // Validate labels against allowlist (security: prevent arbitrary label injection)
              const validPriorities = ['P0', 'P1', 'P2', 'P3'];
              const validTypes = ['bug', 'feature', 'docs', 'chore'];
              const validTeams = ['Core', 'Frontend', 'Infra'];

              const labelsToAdd = [];

              if (validPriorities.includes(labels.priority)) {
                labelsToAdd.push(labels.priority);
              }
              if (validTypes.includes(labels.type)) {
                labelsToAdd.push(labels.type);
              }
              if (validTeams.includes(labels.team)) {
                labelsToAdd.push(labels.team);
              }

              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: labelsToAdd
                });

                console.log(`Applied labels to issue #${issueNumber}:`, labelsToAdd);
              }

            } catch (error) {
              console.error('Triage failed:', error.message);
              // Don't fail the workflow on triage errors
            }
